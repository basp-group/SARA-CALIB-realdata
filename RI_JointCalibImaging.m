function RI_JointCalibImaging(srcName,imPixelSize,imDimx,imDimy,imLambda, imInitThres, ...
     ddeSpacialDim,ddeTemporalRatio,ddeAmplitudeBounds,param_general,RunID)
%% parpool related
NumWorkers = feature('numcores') ;% available num of cores
parallel.defaultClusterProfile('local');
%% Flags
if isfield(param_general,'flag_calibration') 
    flag_calibration=param_general.flag_calibration;
else,flag_calibration =1;
end
if ~flag_calibration || ~ddeSpacialDim
    fprintf('\nINFO: performing imaging only')
elseif ddeSpacialDim==1
    fprintf('\nINFO: performing joint DIE calibration & imaging')
elseif ddeSpacialDim>1
    fprintf('\nINFO: performing joint DDE calibration & imaging')
end
    
if isfield(param_general,'flag_reweighting') 
    %Solving consecutive re-weighted l1 problems
    flag_reweighting=param_general.flag_reweighting;
else,flag_reweighting = 1;
end
if flag_reweighting
    fprintf('\nINFO: solving a sequence of re-weighted l1 problems')
else
    fprintf('\nINFO: solving the l1-regularised problem')
end
if isfield(param_general,'flag_save_tmp_results')
    %saving the results of each iteration of the BCFB algorithm
    flag_save_tmp_results=param_general.flag_save_tmp_results;
else,flag_save_tmp_results =1;
end

if isfield(param_general,'flag_load_previous_results') 
    %starting over from a previous run
    flag_load_previous_results=param_general.flag_load_previous_results;
else,flag_load_previous_results = 0;
end

path_previous_results = [];
if flag_load_previous_results
    
    if isfield(param_general,'path_previous_results')
        path_previous_results=param_general.path_previous_results;
    end
    if isempty(path_previous_results)
        % Will look for the results at the default path
        fprintf('\nINFO: Will fetch results of the previous run at the path generated by default')
    end
end
fprintf("\n________________________________________________________________\n")

%% setting general paths
try  DirProject = param_general.DirProject;
catch
   DirProject = pwd;
   DirProject = [DirProject,filesep];% main DIR
end
addpath(genpath([DirProject,'lib',filesep,'lib_calim',filesep]));% lib DIR
addpath(genpath([DirProject,'lib',filesep,'lib_imaging',filesep]));% lib DIR
addpath(genpath([DirProject,'lib',filesep,'lib_wavelets',filesep]));% lib DIR
fprintf('\nINFO: Project DIR \n ''%s''',DirProject);

irtdir = [DirProject,filesep,'lib',filesep,'external',filesep,'nufft_Fessler2003',filesep];% NUFFT DIR (Fessler 2003)
fprintf('\nINFO: NUFFT DIR \n''%s'' .. ',irtdir);
try run([irtdir,filesep,'setup.m'])
catch, error('NUFFT Path not set correctly');
end

DirData    = [DirProject,'data',filesep];% data DIR
addpath(DirData)
fprintf('\nINFO: Data will be fetched in \n ''%s''',DirData);


DirImageInit = [DirProject,'image_init',filesep];% Image Initialisation
try mkdir(DirImageInit)
end
fprintf('\nINFO: Initial Image will be fetched in \n''%s''',DirImageInit);


DirResults = [DirProject,'results',filesep,'',srcName,filesep];% Results DIR
try mkdir(DirResults);
end
fprintf('\nINFO: Results will be saved in \n ''%s''',DirResults);


%% Data name tag, field ID & path
% Configurations/multiple data sets tags
DataSpecific.dataSetsNameTag  = param_general.ms_dataSetsNameTag;
%Number of data sets 
nDataSets = max(1,numel(DataSpecific.dataSetsNameTag));
% Source field ID
try  DataSpecific.scrFieldId = param_general.ms_scrFieldId;
catch,  DataSpecific.scrFieldId = 0;
end

% Data sets DIR
DirDataSpec  = cell(numel(DataSpecific.dataSetsNameTag),1);
for idataSet =1:nDataSets
    DirDataSpec{idataSet} = [DirData,srcName,filesep,DataSpecific.dataSetsNameTag{idataSet}];
end


fprintf("\n________________________________________________________________\n")

%% initial model image &  path
imInitFileName =  [DirImageInit,srcName,'_',num2str(imDimy),'-',num2str(imDimx),'.fits'];%
fprintf('\nFetching image mode: \n ''%s''',imInitFileName)
if isfile(imInitFileName)
    fprintf("\nINFO: Init. Model Image found  ")
else
    fitswrite(zeros(imDimy,imDimx),imInitFileName);
    if flag_calibration
        error("FATAL ERROR: model image NOT found --> run imaging only first \n")
    end    
end
imInitModel = fitsread(imInitFileName);
if ~nnz(imInitModel)
    fprintf("\nWarning: Image is null!! Consider running imaging only first! \n");
else
    fprintf('\nApplying hard thresholding on the initial model image\n');
    imInitModel = sparse(imInitModel.*(imInitModel>(max(max(imInitModel))* imInitThres)));
end
%% Calibration : dde kernel support size in both time and spatial Fourier domain
% DDEs kernel dimensions
ddeSpatialDimInput = ddeSpacialDim; % except. if no calib
if ddeSpatialDimInput == 0
    ddeSpacialDim = 1;
    flag_calibration =0;
end
ddeSpacialDimDataSets  =  ddeSpacialDim * ones(nDataSets,1);
ddeTemporalDimDataSets = ddeTemporalRatio * ones(nDataSets,1);
fprintf("\n________________________________________________________________\n")

%% Imaging 
%Image dimensions
ImDims = [imDimy imDimx];
%sparsity prior: wavelets settings
param_dict.nlevel = 4;
param_dict.basis = {'db1','db2','db3','db4','db5','db6','db7','db8','self'};

try
    param_dict.nFacetsPerDim =param_general.nFacetsPerDim;
    Qx = param_general.nFacetsPerDim(1);
    Qy = param_general.nFacetsPerDim(2);
    if Qx*Qy>NumWorkers
        fprintf('\nWARNING: Nber of facets required> Nber of workers available. \nConsidering default instead.')
        error('Large number of facets.')
    end
catch
    Qx = floor(sqrt(NumWorkers));
    Qy = floor(NumWorkers/Qx);
    if floor(imDimy/Qy)<256
        Qy = max(1,floor(imDimy/256));
    end
    if floor(imDimx/Qx)<256
        Qx = max(1,floor(imDimx/256));
    end
    param_dict.nFacetsPerDim = [Qy,Qx];
end
param_dict.flag_facet = 1;

%NUFFT settings
param_nufft.ox  = 2;  %zero-padding
param_nufft.oy  = 2;  %zero-padding
param_nufft.Kx = 7;   %kernel dim 1
param_nufft.Ky = 7 ;  %kernel dim 2
% INFO
fprintf("\nINFO: Imaging %d data sets ",nDataSets)
fprintf("\nINFO: NUFFT kernel: Kaiser Bessel: size %d x %d, oversampling along each dim. x%d",param_nufft.Kx,param_nufft.Ky,param_nufft.ox)
fprintf('\nINFO: Image size %d x %d, cellsize %fasec',ImDims(2),ImDims(1),imPixelSize)
fprintf("\nINFO: Image sparsity prior: Wavelets : %d bases, decomposition level = %d",numel(param_dict.basis),param_dict.nlevel)
fprintf("\nINFO: Image sparsity prior: Number of facets : %d x %d",Qy,Qx);

%% Fourier sampling & Fourier operators
FoV   = (imPixelSize/3600) *ImDims(:) *pi /180; %FoV
uvGridSize = 1./([param_nufft.ox; param_nufft.oy].*FoV(:));   %gridsize in the Fourier domain
uvFullBandwidth  = [param_nufft.ox;param_nufft.oy].*uvGridSize(:) .*ImDims(:) ; %Full imaged spatial bandwidth

param_op2CLR.gen_only_fft_op = 1;
[param_nufft.A, param_nufft.At, ~,~, ~,~,~,param_nufft.Scale] = op_p_nufft([{0},{0}], ImDims, [param_nufft.Ky param_nufft.Kx], ...
    [param_nufft.oy param_nufft.ox].*ImDims, ImDims./2,[],param_op2CLR);
clear param_op2CLR;

%% Read data and build measurement operator
PreCalib.Gw = cell(nDataSets,1);
PreCalib.timeslot  = cell(nDataSets,1);
data  = cell(nDataSets,1);
fprintf("\n________________________________________________________________\n")

for idataSet=1:nDataSets
    fprintf('\n!! Data set %d !!',idataSet)
    %% Read general specs of observations
    fprintf('\nReading MS specs file:\n %s ',[DirDataSpec{idataSet},filesep,'msSpecs.mat'])

    dataSpecsCurr   = load([DirDataSpec{idataSet},filesep,'msSpecs.mat']);
    scrFieldIdCurr = ':';
    % select data associated with the source of interest
    try  scrFieldIdCurr = find(dataSpecsCurr.field == DataSpecific.scrFieldId);
    end
     
    msSpecsCurr.ObsTime  = dataSpecsCurr.time(scrFieldIdCurr);
    msSpecsCurr.uvw   = dataSpecsCurr.uvw(scrFieldIdCurr,:);
    freqID = 1;
    if numel(dataSpecsCurr.freqsVect)>1
        try freqID = param_general.ms_freqId;
        end        
    end
    msSpecsCurr.freq0  = dataSpecsCurr.freqsVect(freqID);
    msSpecsCurr.pixel_size = imPixelSize;%arcsec    
 
    %% load data, flag & weights
    fprintf('\nReading data file:\n %s ',[DirDataSpec{idataSet},filesep,'data.mat'] )
    dataCurr = load([DirDataSpec{idataSet},filesep,'data.mat']);
    DataStructCurr.y_I     = dataCurr.y_I(scrFieldIdCurr); dataCurr.y_I =[];
    DataStructCurr.flag    = dataCurr.flag(scrFieldIdCurr); dataCurr.flag =[];
    DataStructCurr.weights = dataCurr.weights(scrFieldIdCurr); dataCurr.weights =[];
    try
        msSpecsCurr.ant2 = 1+dataCurr.ant2(scrFieldIdCurr);
        msSpecsCurr.ant1  = 1+dataCurr.ant1(scrFieldIdCurr);
    catch
        msSpecsCurr.ant2 = 1+dataSpecsCurr.ant2(scrFieldIdCurr);
        msSpecsCurr.ant1  = 1+dataSpecsCurr.ant1(scrFieldIdCurr);
    end
    
    clear dataCurr dataMsCurr;
    %% re-structure data and associated specs
    fprintf("\nStructuring data and specs %d ..",idataSet)
     
    [data{idataSet},gVars,PreCalib.timeslot{idataSet}] = util_get_data_struct(DataStructCurr,msSpecsCurr);
    clear msSpecsCurr DataStructCurr;
    
    data{idataSet}.DataDims = gVars.MeasNum;    
    param_dataOrder.order1{idataSet} = PreCalib.timeslot{idataSet}.order1;  PreCalib.timeslot{idataSet}.order1 =[];
    param_dataOrder.order2{idataSet} = PreCalib.timeslot{idataSet}.order2;  PreCalib.timeslot{idataSet}.order2 =[];
    param_dataOrder.partition{idataSet}  = data{idataSet}.DataDims;
    
    %% measurement operator initialization
    uNZ = cell2mat(PreCalib.timeslot{idataSet}.u) *pi./(uvFullBandwidth(2)/2);  PreCalib.timeslot{idataSet}.u =[];
    vNZ = cell2mat(PreCalib.timeslot{idataSet}.v) *pi./(uvFullBandwidth(1)/2);  PreCalib.timeslot{idataSet}.v =[];
    param_moCurr.flag =[];
    fprintf('\nBuilding  measurement operator ..')
    [~, ~, ~,~, PreCalib.Gw{idataSet},~,~,~] = op_p_nufft([{-vNZ},{uNZ}],ImDims,...
        [param_nufft.Ky param_nufft.Kx], [param_nufft.oy param_nufft.ox].*ImDims, ...
        ImDims./2,{(data{idataSet}.nW)},param_moCurr);
    clear  uNZ vNZ param_moCurr ;
    data{idataSet}.nW =[];
    %% operator norm
    fprintf('Computing the spectral norm ..\n')
    data{idataSet}.MeasOpNorm = op_norm(@(x) PreCalib.Gw{idataSet} * param_nufft.A(x), @(x) param_nufft.At(PreCalib.Gw{idataSet}' * x), ImDims, 5e-4, 200, 0);
    
    clear *Curr;
end

%% Init. for calib
fprintf("\n________________________________________________________________\n")

script_build_calib_imaging_structs;
fprintf("\n________________________________________________________________\n")

%% INFO
disp(param_algo)
disp(param_imaging)
fprintf("\n________________________________________________________________\n")

%% Joint CALIB & Imaging
if param_algo.flag_calib
    fprintf( '\nJoint Calibration & Imaging starting .. ');
    nameSaveResults=[param_imaging.path,'results_JointCalim_ID',num2str(RunID),...
        '_ddeS',num2str(ddeSpacialDim),...
        '_ddetau',num2str(ddeTemporalRatio),...
        '_ddeAmp', num2str(ddeAmplitudeBounds),...
        '_imReg',num2str(imLambda),'.mat'];
    nameSaveFits=[param_imaging.path,'JointCalim_ID',num2str(RunID),...
        '_ddeS',num2str(ddeSpacialDim),...
        '_ddetau',num2str(ddeTemporalRatio),...
        '_ddeAmp', num2str(ddeAmplitudeBounds),...
        '_imReg',num2str(imLambda)];
else
    fprintf( '\nImaging starting .. ');
    
    nameSaveResults=[param_imaging.path,'results_Im_ID',num2str(RunID),...  
    '_imReg',num2str(imLambda),'.mat'];
    nameSaveFits=[param_imaging.path,'Im_ID',num2str(RunID),...   
    '_imReg',num2str(imLambda)];
end

RESULTS = solver_JointCalibImaging_BCFB(param_imaging, calib_param_dde, param_algo, calib_param_data);

clear calib_param_dde calib_param_data;
%% save results
fprintf('\nSaving final results ..');
fitswrite(RESULTS.MODEL,[nameSaveFits,'_MODEL.fits']);
fitswrite(RESULTS.ResidualIm,[nameSaveFits,'_RESIDUAL.fits']);
disp(nameSaveResults)
save(nameSaveResults,'RESULTS', 'param_algo' ,'-v7.3')

fprintf('\nTHE END')
end
